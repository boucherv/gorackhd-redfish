package redfish_v1

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"
	"io"

	"github.com/go-swagger/go-swagger/client"
	"github.com/go-swagger/go-swagger/httpkit"

	strfmt "github.com/go-swagger/go-swagger/strfmt"

	"github.com/emccode/gorackhd-redfish/models"
)

// DoResetReader is a Reader for the DoReset structure.
type DoResetReader struct {
	formats strfmt.Registry
}

// ReadResponse reads a server response into the recieved o.
func (o *DoResetReader) ReadResponse(response client.Response, consumer httpkit.Consumer) (interface{}, error) {
	switch response.Code() {

	case 202:
		result := NewDoResetAccepted()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return result, nil

	case 400:
		result := NewDoResetBadRequest()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	case 401:
		result := NewDoResetUnauthorized()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	case 403:
		result := NewDoResetForbidden()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	case 404:
		result := NewDoResetNotFound()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	case 500:
		result := NewDoResetInternalServerError()
		if err := result.readResponse(response, consumer, o.formats); err != nil {
			return nil, err
		}
		return nil, result

	default:
		return nil, client.NewAPIError("unknown error", response, response.Code())
	}
}

// NewDoResetAccepted creates a DoResetAccepted with default headers values
func NewDoResetAccepted() *DoResetAccepted {
	return &DoResetAccepted{}
}

/*DoResetAccepted handles this case with default header values.

The request has been accepted for processing, but the processing has not been completed.  The Location header shall be set to the URI of a Task resource that can later be queried  to determine the status of the operation. A representation of the Task resource may be  included in the response body.

*/
type DoResetAccepted struct {
}

func (o *DoResetAccepted) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetAccepted ", 202)
}

func (o *DoResetAccepted) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewDoResetBadRequest creates a DoResetBadRequest with default headers values
func NewDoResetBadRequest() *DoResetBadRequest {
	return &DoResetBadRequest{}
}

/*DoResetBadRequest handles this case with default header values.

The request could not be processed because it contains missing or invalid information  (such as validation error on an input field, a missing required value, and so on).  An extended error shall be returned in the response body, as defined in section Extended  Error Handling.

*/
type DoResetBadRequest struct {
}

func (o *DoResetBadRequest) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetBadRequest ", 400)
}

func (o *DoResetBadRequest) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewDoResetUnauthorized creates a DoResetUnauthorized with default headers values
func NewDoResetUnauthorized() *DoResetUnauthorized {
	return &DoResetUnauthorized{}
}

/*DoResetUnauthorized handles this case with default header values.

The authentication credentials included with this request are missing or invalid.

*/
type DoResetUnauthorized struct {
}

func (o *DoResetUnauthorized) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetUnauthorized ", 401)
}

func (o *DoResetUnauthorized) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewDoResetForbidden creates a DoResetForbidden with default headers values
func NewDoResetForbidden() *DoResetForbidden {
	return &DoResetForbidden{}
}

/*DoResetForbidden handles this case with default header values.

The server recognized the credentials in the request, but those credentials do not  possess authorization to perform this request.

*/
type DoResetForbidden struct {
}

func (o *DoResetForbidden) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetForbidden ", 403)
}

func (o *DoResetForbidden) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewDoResetNotFound creates a DoResetNotFound with default headers values
func NewDoResetNotFound() *DoResetNotFound {
	return &DoResetNotFound{}
}

/*DoResetNotFound handles this case with default header values.

The request specified a URI of a resource that does not exist.

*/
type DoResetNotFound struct {
}

func (o *DoResetNotFound) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetNotFound ", 404)
}

func (o *DoResetNotFound) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	return nil
}

// NewDoResetInternalServerError creates a DoResetInternalServerError with default headers values
func NewDoResetInternalServerError() *DoResetInternalServerError {
	return &DoResetInternalServerError{}
}

/*DoResetInternalServerError handles this case with default header values.

Error
*/
type DoResetInternalServerError struct {
	Payload *models.ErrorResponse
}

func (o *DoResetInternalServerError) Error() string {
	return fmt.Sprintf("[POST /Systems/{identifier}/Actions/ComputerSystem.Reset][%d] doResetInternalServerError  %+v", 500, o.Payload)
}

func (o *DoResetInternalServerError) readResponse(response client.Response, consumer httpkit.Consumer, formats strfmt.Registry) error {

	o.Payload = new(models.ErrorResponse)

	// response payload
	if err := consumer.Consume(response.Body(), o.Payload); err != nil && err != io.EOF {
		return err
	}

	return nil
}
